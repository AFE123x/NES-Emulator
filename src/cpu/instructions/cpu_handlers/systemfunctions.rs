use crate::cpu::Cpu;
use crate::cpu::Flags;
impl Cpu{
    pub fn brk(&mut self) {
        // Increment PC by 1 because BRK is a 2-byte instruction
        // (the second byte is padding and is typically skipped when executing)
        self.pc += 1;
        
        // Push the program counter to the stack
        let lo_byte = self.pc & 0xFF;
        let hi_byte = self.pc >> 8;
        self.push(hi_byte as u8);
        self.push(lo_byte as u8);
        
        // Push the status register to the stack
        // Note: The B flag should be set in the copy pushed to the stack
        self.flags.set(Flags::Break, true);
        self.flags.set(Flags::Unused, true);
        self.push(self.flags.bits());
        
        // Set the interrupt disable flag
        self.flags.set(Flags::IDisable, true);
        
        // Load the IRQ/BRK vector (same vector is used for both)
        let lo_byte = self.cpu_read(0xFFFE, false) as u16;
        let hi_byte = self.cpu_read(0xFFFF, false) as u16;
        self.pc = (hi_byte << 8) | lo_byte;
        
        // BRK takes 7 cycles
        self.cycles_left = 7;
    }
    ///# `RTI` - Return from Interrupt
    /// - The RTI instruction is used at the end of an interrupt processing routine. It pulls the processor flags from the stack followed by the program counter.
    pub fn rti(&mut self) {
        self.flags = Flags::from_bits_truncate(self.pop());
        let lo_byte = self.pop() as u16;
        let hi_byte = self.pop() as u16;
        self.pc = (hi_byte << 8) | lo_byte;
    }

    ///# `nmi` - Non Maskable Interrupts
    /// - NMI (Non-Maskable Interrupt) is the type of interrupt generated by the PPU when V-Blank occurs at the end of each frame.
    /// - To facilitate a interrupt, we must follow the following steps
    /// - Push the program counter and status register on to the stack.
    /// - Set the interrupt disable flag to prevent further interrupts.
    /// - Load the address of the interrupt handling routine from the vector table into the program counter.
    /// - Execute the interrupt handling routine(located at address $FFFA and $FFFB)
    pub fn nmi(&mut self) {
        /* Push the program counter */
        let lo_byte = self.pc & 0xFF;
        let hi_byte = self.pc >> 8;
        self.push(hi_byte as u8);
        self.push(lo_byte as u8);

        /* Push the status register */
        self.push(self.flags.bits());
        self.flags.set(Flags::IDisable,true);

        /* Retrieve the location of NMI handler */
        let lo_byte = self.cpu_read(0xFFFA, false) as u16;
        let hi_byte = self.cpu_read(0xFFFB, false) as u16;
        self.pc = (hi_byte << 8) | lo_byte;
    }
    
    pub fn reset(&mut self) {
        self.a = 0;
        self.x = 0;
        self.y = 0;
        let lo_byte = self.cpu_read(0xFFFC, false) as u16;
        let hi_byte = self.cpu_read(0xFFFD, false) as u16;
        self.pc = (hi_byte << 8) | lo_byte;
        self.flags = Flags::empty();
        self.flags.set(Flags::Unused, true);
        self.cycles_left = 8;
        self.total_cycles = 0;
    }
}